<!doctype html>
<html>
  
  <head>
    <title>CPP.01.2</title>
    <link rel=" shortcut icon" href="../../favicon (3).ico">
    <link rel="icon" href="../../favicon (3).ico">
    <meta charset="utf-8">
    <link rel="stylesheet" href="../../style.css">
<link rel="stylesheet"
      href="//unpkg.com/@highlightjs/cdn-assets@11.2.0/styles/tomorrow-night-blue.min.css">
<script src="//unpkg.com/@highlightjs/cdn-assets@11.2.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  
  <body>
    <center>
      "이제 나는 <em><a href="../../index.html">
      어떠한 저항도 하지 않기로</a></em> 결심했다."
      <br>1914년 8월 26일, 비트겐슈타인.<br>
      
      <hr width="50%" color="#1733a5" noshade>
      
      <a href="../../Logic/Log.html">논리학</a>
      &nbsp;
      <a href="../../Mathematics/Mat.html">수학</a> 
      &nbsp;
      <a href="../../Physics/Phy.html">물리학</a>
      &nbsp;
      <mark id="red">전산학</mark>
      &nbsp;
      <a href="../../ComputerEngineering/CoE.html">컴퓨터공학</a>
      &nbsp;
      <a href="../../MediaStudies/MeS.html">매체학</a>
      &nbsp;
      <a href="../../Music/Mus.html">음악</a>
      &nbsp;
      <a href="../../Philosophy/Phi.html">철학</a>
      
      <hr width="70%" color="#1733a5" noshade>

    </center>
    <div class="row">
    <div class="left">
        <ul>    
          <li><mark id="red">『C++ 기초』</mark></li>
          <li><a href="../EffectiveC++/CoS.ECP.html">『이펙티브 C++』</a></li>
          <li><a href="../EffectiveSTL/CoS.ECS.html">『이펙티브 STL』</a></li>
          <li><a href="../EffectiveModernC++/CoS.EMC.html">『이펙티브 모던 C++』</a></li>
          <li><a href="../DataStructures_inC++/CoS.CDS.html">『C++ 자료구조론』</a></li>
          <li><a href="../Introduction_toAlgorithms/CoS.ITA.html">『알고리즘 개론』</a></li>
          <li><a href="../Introduction_toTheory_ofComputation/CoS.ITC.html">『전산 이론 개론』</a></li>
          <li><a href="../ComputationalComplexity/CoS.CCM.html">『계산 복잡도』</a></li>
        </ul>
    </div>
    <div class="center">
    <ul>
      <li>01장 <mark id="red">시작하기</mark></li>
      <li>02장 <a href="CoS.CPP.02.html">기본</a></li>
      <li>03장 <a href="CoS.CPP.03.html">스트링, 벡터, 배열</a></li>
      <li>04장 <a href="CoS.CPP.04.html">표현식</a></li>
      <li>05장 <a href="CoS.CPP.05.html">문장</a></li>
      <li>06장 <a href="CoS.CPP.06.html">함수</a></li>
      <li>07장 <a href="CoS.CPP.07.html">클래스</a></li>
      <li>08장 <a href="CoS.CPP.08.html">IO 라이브러리</a></li>
      <li>09장 <a href="CoS.CPP.09.html">순차 컨테이너</a></li>
      <li>10장 <a href="CoS.CPP.10.html">유전 알고리즘</a></li>
      <li>11장 <a href="CoS.CPP.11.html">연관 컨테이너</a></li>
      <li>12장 <a href="CoS.CPP.12.html">동적 메모리</a></li>
      <li>13장 <a href="CoS.CPP.13.html">복사 제어</a></li>
      <li>14장 <a href="CoS.CPP.14.html">오버로드된 연산자 및 변환</a></li>
      <li>15장 <a href="CoS.CPP.15.html">객체 지향 프로그래밍</a></li>
      <li>16장 <a href="CoS.CPP.16.html">템플릿과 일반화 프로그래밍</a></li>
      <li>17장 <a href="CoS.CPP.17.html">라이브러리 특수 기능</a></li>
      <li>18장 <a href="CoS.CPP.18.html">대형 프로그램을 위한 도구</a></li>
      <li>19장 <a href="CoS.CPP.19.html">특수 도구 및 기법</a></li>
      <li>부록 A <a href="CoS.CPP.20.html">라이브러리</a></li>
    </ul>
    </div>
    <div class="right">
    <ul>
        <li>1.1 <a href="CoS.CPP.01.1.html">간단한 C++ 프로그램 작성하기</a></li>
        <li>1.1.1 <a href="CoS.CPP.01.1.1.html">프로그램 컴파일 및 실행</a></li>
        <li>1.2 <mark id="red">입력/출력 소개</mark></li>
        <li>1.3 <a href="CoS.CPP.01.3.html">주석에 관해</a></li>
        <li>1.4 <a href="CoS.CPP.01.4.html">흐름 제어</a></li>
        <li>1.4.1 <a href="CoS.CPP.01.4.1.html"><mark id="blue">while</mark>문</a></li>
        <li>1.4.2 <a href="CoS.CPP.01.4.2.html"><mark id="blue">for</mark>문</a></li>
        <li>1.4.3 <a href="CoS.CPP.01.4.3.html">미지수 입력 읽기</a></li>
        <li>1.4.4 <a href="CoS.CPP.01.4.4.html"><mark id="blue">if</mark>문</a></li>
        <li>1.5 <a href="CoS.CPP.01.5.html">클래스 소개</a></li>
        <li>1.5.1 <a href="CoS.CPP.01.5.1.html"><mark id="blue">Sales_item</mark> 클래스</a></li>
        <li>1.5.2 <a href="CoS.CPP.01.5.2.html">멤버 함수 소개</a></li>
        <li>1.6 <a href="CoS.CPP.01.6.html">서점 프로그램</a></li>
        <li><a href="CoS.CPP.01.Sum.html">요약</a></li>
        <li><a href="CoS.CPP.01.Def.html">정의된 용어</a></li>
      </ul>
    </div>  
    </div>     
      <hr width="100%" color="#1733a5" noshade>
      <p>
        C++ 언어에는 입력 및 출력(IO) 수행이 정의된 문장이 없다. 대신, C++는 광범위한 <mark id="red">표준 라이브러리</mark>(standard library)를 통해 IO를(비롯한 여러 기능을) 제공한다. 이 책의 예제를 포함한 다양한 상황에서는 IO 라이브러리에서 기본 개념 몇 가지만 알면 된다.
      </p>
      <p>
        이 책의 예제는 대부분 <mark id="blue">iostream</mark> 라이브러리를 사용한다. <mark id="blue">iostream</mark> 라이브러리에서 근본적인 것은 <mark id="blue">istream</mark>과 <mark id="blue">ostream</mark>이라는 이름의 두 가지 타입으로, 입력 및 출력 스트림(streams)이라는 뜻이라고 말할 수 있다. 스트림이란 IO 장치에서 읽히거나 쓰인 일련의 문자(sequence of character)다. <mark>스트림</mark>이라는 용어는 문자들이 시간의 흐름에 따라 순차적으로 생성되거나 소비되었다는 점을 암시하기 위한 것이다.  
      </p>
      <p>
        <h4> 표준 입력 및 출력 객체</h4>
        라이브러리는 네 가지 IO 객체를 정의한다. 입력을 다루기 위해 <mark id="blue">cin</mark>이라는 이름의 <mark id="blue">istream</mark> 타입 객체를 사용한다. 이 객체는 <mark id="red">표준 입력</mark>(standard input)이라고 지시되기도 한다. 출력을 다루기 위해서는 <mark id="blue">cout</mark>이라고 불리는 <mark id="blue">ostream</mark> 객체를 사용한다. 이 객체 또한 <mark id="red">표준 출력</mark>(standard output)이라고 알려져 있다. 라이브러리는 두 가지 또 다른 <mark id="blue">ostream</mark> 객체를 정의하는데, <mark id="blue">cerr</mark>과 <mark id="blue">clog</mark>라고 불리는 (<mark>씨-얼</mark> 그리고 <mark>씨-로그</mark>라고 발음되는) 것들이다. <mark id="blue">cerr</mark>은 <mark id="red">표준 오류</mark>(standard error)라는 것을 지시하기 위해 쓰여, 경보와 오류 메시지를 위한 것이고, <mark id="blue">clog</mark>는 프로그램 실행에 관한 일반적인 정보를 위해 쓰인다.
        <p>
        일반적으로 시스템은 프로그램이 실행되는 창(window)을 통해 이들 객체와 교류한다. 따라서 <mark id="blue">cin</mark>을 통해 읽을 때, 자료는 프로그램이 실행되는 창을 통해 입력되고, <mark id="blue">cout</mark>, <mark id="blue">cerr</mark>, <mark id="blue">clog</mark>에 적을 때의 출력 또한 같은 창에서 작성된다.   
        </p>  
       </p>
        <p>      
        <h4>IO 라이브러리를 사용하는 프로그램</h4>
        우리의 서점 프로그램에는 단일의 총합으로 합칠 여러 가지 데이터가 있다. 더 단순한 관련 문제로, 어떻게 두 수를 합칠 수 있을지 살펴보자. IO 라이브러리를 통해, 사용자에게 두 수를 받은 다음 그 합을 출력하도록 <mark id="blue">main</mark> 프로그램을 확장할 수 있다. 
        <pre><code>#include <iostream>
int main()
{
    std::cout << "Enter two numbers:" << std::endl;
    int v1 = 0, v2 = 0;
    std::cin >> v1 >> v2;
    std::cout << "The sum of " << v1 << " and " << v2
              << " is " << v1 + v2 << std::endl;
    return 0;
}</code></pre>
        이 프로그램은 사용자의 스크린에 다음 문장을 출력하면서 시작한다.
        <pre><code>Enter two numbers: </code></pre>
        그런 다음 사용자에게서 입력을 기다린다. 만약 사용자가 아래처럼 입력한 다음 개행(newline)을 입력했다면
        <pre><code>3 7</code></pre>
        프로그램은 다음과 같은 출력을 생산한다.
        <pre><code>The sum of 3 and 7 is 10</code></pre>
        프로그램 첫 라인인 아래 라인은
        <pre><code>#include <iostream></code></pre>
        컴파일러에 우리가 <mark id="blue">iostream</mark> 라이브러리를 사용하고 싶다고 전달한다. 꺾쇠 안의 이름은 (이 경우에는 <mark id="blue">iostream</mark>인데) <mark id="red">헤더</mark>(header)를 지시한다. 라이브러리를 사용하는 모든 프로그램은 관련 헤더를 포함해야 한다. <mark id="blue">#include</mark>는 단일 라인에서 작성되어야 하는데, 곧 헤더 이름과 <mark id="blue">#include</mark>가 같은 문장에 나타나야 한다는 말이다. 일반적으로, <mark id="blue">#include</mark>는 모든 함수 바깥에 나타나야 한다. 특징적으로는, 모든 <mark id="blue">#include</mark>를 소스 파일 시작 부분에 배치한다.
        </p>
        
        <p>
        <h4>스트림에 작성하기</h4>
        <mark id="blue">main</mark> 몸체의 첫 번째 문장은 <mark id="red">표현식</mark>(expression)을 실행시킨다. C++에서 표현식은 하나의 결과를 가져오고 하나 이상의 피연산자와 (보통) 하나의 연산자로 구성된다. 이 문장에서 표현식은 출력 연산자를 (<mark id="blue"><< 연산자</mark>를) 사용해 메시지를 표준 출력으로 출력한다.
        <pre><code>std::cout << "Enter two numbers:" << std::endl;</code></pre>
        <mark id="blue"><<</mark> 연산자는 두 개의 피연산자를 취한다. 좌측 피연산자는 <mark id="blue">ostream</mark> 객체여야만 한다. 우측 피연산자는 출력할 값이다. 연산자는 주어진 <mark id="blue">ostream</mark>에 주어진 값을 기재한다. 출력 연산자의 결과물은 자신의 좌측 피연산자다. 즉, 우리가 기재한 주어진 값에 대한 <mark id="blue">ostream</mark>이 결과물이라는 것이다.
        <p>
        우리의 출력문에는 <mark id="blue"><<</mark> 연산자가 두 번 쓰였다. 이는 연산자가 좌측 피연산자를 반환할 때, 첫 번째 연산자의 결과가 두 번째 연산자의 좌측 피연산자가 되기 때문이다. 결과적으로, 우리는 출력 요청을 연결 지을 수 있다. 따라서, 우리의 표현식은 아래 라인과 동치다.
        </p>
        <pre><code>(std::cout << "Enter two numbers:") << std::endl;</code></pre>
        여기서 각 연산자는 같은 객체를 좌측 피연산자로 갖고 있으며, 그것이 이 경우에는 <mark id="blue">std::cout</mark>이다. 대안적으로, 같은 출력물을 문장 두 개로 조성할 수 있다.
        <pre><code>std::cout << "Enter two numbers: ";
std::cout << std::endl;</code></pre>
        여기서 첫 번째 출력 연산자가 사용자에게 메시지를 출력한다. 그 메시지는 <mark id="red">스트링 리터럴</mark>(string literal)인데, 이는 큰따옴표로 묶인 일련의 문자다. 큰따옴표 사이의 텍스트는 표준 출력으로 출력된다.
        <p>
        두 번째 연산자는 <mark id="blue">endl</mark>을 출력하는데, 이는 <mark id="red">조작자</mark>(manipulator)라고 불리는 특별한 값이다. <mark id="blue">endl</mark>이라고 씀으로써 현재 라인을 끝내고 그 장치에 연관된 <mark>버퍼</mark>(buffer)를 비우는 효과를 갖는다. 버퍼를 비우는 일은 지금껏 프로그램이 만들어낸 모든 출력물이 메모리에서 쓰이기를 기다리는 것이 아니라 실제로 출력 스트림에 쓰였다는 점을 보장한다.
        </p>
        </p>
        <div class="note">
          <h4>경고</h4>
          프로그래머들은 종종 디버깅 과정에서 문장을 출력한다. 이와 같은 문장은 <mark>언제나</mark> 스트림을 비워야 한다. 그러지 않는다면, 프로그램이 깨졌을 때, 출력물이 버퍼에 남아, 어디서 프로그램이 깨진 건지에 관한 잘못된 추론으로 이끌 수 있기 때문이다.
        </div>
        
        <p>
  <h4>표준 라이브러리에서 이름 사용하기</h4>
  주의 깊은 독자라면 이 프로그램이 단지 <mark id="blue">cout</mark>와 <mark id="blue">endl</mark>이 아니라 <mark id="blue">std::cout</mark>와 <mark id="blue">std::endl;</mark>를 사용한다는 점을 눈치챘을 것이다. 접미사(prefix) <mark id="blue">std::</mark>는 <mark id="blue">cout</mark>과 <mark id="blue">endl</mark>과 같은 이름이 <mark id="red">std</mark>라는 이름의 <mark id="red">이름공간</mark>(namespace) 안에 정의되어 있다는 점을 암시한다. 이름공간은 라이브러리 내부의 이름과 우리가 정의한 이름 간의 충돌을 피하게 해준다. 표준 라이브러리에 의해 정의된 모든 이름은 <mark id="blue">std</mark> 이름공간에 있다.
  <p>
    이름공간 사용의 부작용은, 우리가 라이브러리에서 이름을 사용할 때, 우리가 <mark id="blue">std</mark> 이름공간에서 가져오고자 하는 이름을 명시해야 한다는 점이다. <mark id="blue">std::cout</mark>에는 범위 연산자(scope operator, <mark id="red">:: 연산자</mark>)가 쓰였으며, 이는 우리가 <mark id="blue">std</mark> 이름공간에서 정의된 이름인 <mark id="blue">cout</mark>을 사용하고 싶다는 뜻이다. § 3.1에는 라이브러리에서 이름을 가져올 수 있는 더 간단한 방법을 소개할 것이다.
  </p>
        </p>

<p>
<h4>스트림에서 읽기</h4>
사용자에게 입력을 요청했으니, 이제는 그 입력을 읽어야겠다. 우선 <mark id="blue">v1</mark>과 <mark id="blue">v2</mark>라는 이름의 두 <mark id="red">변수</mark>(variables)를 정의하여 입력을 붙잡자.
<pre><code>int v1 = 0, v2 = 0;</code></pre>
우리는 이 변수들을 <mark id="blue">int</mark> 타입으로 정의했는데, 이는 정수를 표현하는 내장형 타입이다. 우리는 또한 이들을 <mark id="blue">0</mark>으로 <mark id="red">초기화</mark>(initialize)할 것이다. 변수를 초기화할 때, 우리는 변수가 만들어지는 것과 동시에 변수에 의도하는 값을 부여한다.
<p>
  다음 문장은 입력을 읽는다.
<pre><code>std::cin >> v1 >> v2;</code></pre>
입력 연산자는 (<mark id="blue">>>연산자는</mark>) 출력 연산자와 비슷하게 행동한다. <mark id="blue">isstream</mark>을 좌측 피연산자로 취하며, 객체를 우측 피연산자로 취한다. 주어진 <mark id="blue">isstream</mark>에서 자료를 취한 다음 주어진 객체에서 읽힌 것을 저장한다. 출력 연산자와 마찬가지로, 입력 연산자 또한 자신의 좌측 피연산자를 결과물로 반환한다. 따라서, 이 표현식은 아래와 동치다.
<pre><code>(std::cin >> v1) >> v2;</code></pre>
연산자가 자신의 좌측 피연산자를 반환하기에, 우리는 일련의 입력 요청을 하나의 문장으로 묶을 수 있다. 우리의 입력 동작은 <mark id="blue">std::cin</mark>에서 두 가지 값을 읽어, 첫 번째 값을 <mark id="blue">v1</mark>에 저장하고 두 번째 값을 <mark id="blue">v2</mark>에 저장한다. 달리 말해, 우리의 입력 연산자는 다음처럼 실행된다.
<pre><code>std::cin >> v1;
std::cin >> v2;</code></pre>
</p>
</p>

<p>
<h4>프로그램 완성하기</h4>
결과물 출력이 남았다.
<pre><code>std::cout << "The sum of " << v1 << " and " << v2
          << " is " << v1 + v2 << std::endl;</code></pre>
이 문장은, 입력 요청 문장보다는 길지만, 개념적으로 유사하다. 각 피연산자를 표준 출력상에 출력한다. 이 예제에서 흥미로운 점은 바로 피연산자가 다른 종류의 값을 갖는다는 것이다. 어떤 피연산자는 스트링 리터럴로, <mark id="blue">"The sum of "</mark>를 예로 들 수 있다. 다른 종류로는 <mark id="blue">int</mark> 값이 있으며, <mark id="blue">v1</mark>, <mark id="blue">v2</mark>, 그리고 연산 표현식 <mark id="blue">v1 + v2</mark>의 검사 결과가 그 예다. 라이브러리는 다양한 판본의 출력과 입력 연산자를 정의하여 이들처럼 다양한 유형의 피연산자를 다룰 수 있도록 만든다.
</p>

<div class="note">
  <h4>연습문제 1.2</h4>
  <h5>연습문제 1.3</h5>
  <mark id="blue">Hello, World</mark>를 표준 출력으로 출력하는 프로그램을 작성할 것.
  <h5>연습문제 1.4</h5>
  우리의 프로그램은 덧셈 연산자를 사용하였는데, 곱셈 연산자를 사용해 곱셈을 출력할 것.
  <h5>연습문제 1.5</h5>
  우리는 출력물을 하나의 거대한 문장에 작성했는데, 피연산자 하나씩 문장을 나눠볼 것.
  <h5>연습문제 1.6</h5>
  <pre><code>std::cout << "The sum of " << v1;
          << " and " << v2;
          << " is " << v1 + v2 << std::endl;</code></pre>
  이 프로그램이 타당하다면, 무엇을 수행하는가? 프로그램이 부당하다면, 왜 그런가? 어떻게 고칠 것인가? 
</div>

  </body>
</html>
